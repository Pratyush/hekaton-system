flowchart LR
    pub-in-- "regs" --> TPU
    pub-in-- "pc" --> TPU
    pub-in-- "chal" --> TPU
    pub-in-- "t" --> TPU
    pub-in-- "evals" --> TPU

    TPU:::chip -- "instr" --> CPU:::chip
    TPU -- "regs" --> CPU
    CPU --"regs'" --> TPU
    CPU -- "pc'" --> TPU
    CPU -- "dec_memop" --> TPU

    trt:::chip -- "memop^(t)" --> TPU
    trt -- "memop^(t)" --> CPU
    trt -- "pcload" --> TPU

    trm:::chip -- "memopᵢ^(m)" --> TPU
    trm -- "memopᵢ₊₁^(m)" --> TPU

    TPU -- "regs'" --> pub-out
    TPU -- "pc'" --> pub-out
    TPU -- "t'" --> pub-out
    TPU -- "evals'" --> pub-out

    subgraph otherchips[" "]
        direction TB
        subgraph trt["transcript^(t)"]
        end
        subgraph trm["transcript^(m)"]
        end
        subgraph CPU["ExecChecker"]
            cpustep:::text
        end
    end

    subgraph TPU["TranscriptChecker"]
        direction TB
        timestep:::text-->memcheck:::text
    end
    classDef var fill:#f96,stroke:#f96;
    classDef text text-align:left;
    classDef chip fill:#fffdd6,stroke:#a19f76;
    classDef holder fill:#fff,stroke:#fff;
    class otherchips holder
    class absorb chip

timestep["
TimeCheck:
1. Run CPU: recv regs', pc', and dec_memop
2. Recv pcload and memop^(t) from tr
3. Check dec_memop = memop^(t)
4. Check pc == pcload.pc
5. Let t' = incr(t)
6. Absorb memop^(t) & pcload into evals.time_tr_exec
"]
memcheck["
MemCheck:
1. Check memopᵢ^(m), memopᵢ₊₁^(m) are consistent
2. Absorb memopᵢ₊₁^(m) into evals.mem_tr_exec
3. If memopᵢ₊₁^(m) is an initial load:
░░░░absorb into evals.tr_init_accessed
"]
cpustep["
1. Run instr using the given RAM value if required
2. Log the memory operation performed, if any
3. Return the op, the new pc, and the new regs
"]
