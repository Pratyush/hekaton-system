// Enforce whitespace between sequenced tokens (except for in @ or $ rules)
WHITESPACE = _{ " " | "\t" }

// The TinyRAM header has almost no leeway in parsing
header = ${ "; TinyRAM V=2.000 M=" ~ arch ~ " W=" ~ word_size ~ " K=" ~ num_regs }
// Harvard or Von-Neumman architecture
arch = { "hv" | "vn" }
word_size = { ASCII_DIGIT+ }
num_regs = { ASCII_DIGIT+ }

// A register is rX where X is a digit
dec_num = { ASCII_DIGIT+ }
label = @{ "_" ~ (ASCII_DIGIT | ASCII_ALPHA)+ }
reg = ${ "r" ~ dec_num }
// An immediate is either a number or a jump label
imm = { dec_num | label }
imm_or_reg = { imm | reg }

// Parse reg, reg, imm-or-reg instructions
rri_instr_mnemonic = { "add" | "or" | "xor" }
rri_instr_inputs = { reg ~ "," ~ reg ~ "," ~ imm_or_reg }
// The mnemonic (i.e., opcode) must be separated from the inputs with whitespace
rri_instr_begin = @{ rri_instr_mnemonic ~ WHITE_SPACE }
rri_instr = { rri_instr_begin ~ rri_instr_inputs }

// Parse reg, imm-or-reg instructions. Similar to above
ri_instr_mnemonic = { "not" | "cmpe" | "load.w" }
ri_instr_inputs = { reg ~ "," ~ imm_or_reg }
ri_instr_begin = @{ ri_instr_mnemonic ~ WHITE_SPACE }
ri_instr = { ri_instr_begin ~ ri_instr_inputs }

// Parse imm-or-reg, reg instructions. Similar to above
ir_instr_inputs = { imm_or_reg ~ "," ~ reg }
ir_instr_mnemonic = { "store.w" }
ir_instr_begin = @{ ir_instr_mnemonic ~ WHITE_SPACE }
ir_instr = { ir_instr_begin ~ ir_instr_inputs }

// Parse imm-or-reg instructions. Similar to above
i_instr_inputs = { imm_or_reg }
i_instr_mnemonic = { "jmp" | "cjmp" | "answer" }
i_instr_begin = @{ i_instr_mnemonic ~ WHITE_SPACE }
i_instr = { i_instr_begin ~ i_instr_inputs }

// Read comment until newline or end-of-input
comment = ${ "//" ~ (!(NEWLINE | EOI) ~ ANY)* }

// A line is a label, followed by an optional instruction, followed by an optional comment
any_instr = { i_instr | ir_instr | ri_instr | rri_instr }
label_and_colon = @{ label ~ ":" }
full_instr = { WHITESPACE* ~ label_and_colon? ~ any_instr }
line = { full_instr? ~ comment? }

// A file is made up of newline-delimited lines
lines = { NEWLINE+ ~ line }
file = { SOI ~ header ~ lines* ~ EOI }
